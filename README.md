# Comprehensive Test Plan

This repository contains a SAT solver implementation using a custom approach for 3-SAT instances. The program reads input clauses, processes them using sorting, padding, and forbidden vectors, and attempts to generate satisfying assignments.

## Testing Guide

### Program Overview
The program is divided into several phases:
1. **Reading Clauses**: The program reads clauses from standard input and skips any literals that are 0.
2. **Building Variable List**: Constructs a sorted list of distinct variables from the given clauses.
3. **Processing Clauses**: Each clause is processed by detecting contradictions, sorting literals, and building forbidden bitvectors.
4. **Generating Assignments**: The program generates all possible assignments that satisfy the constraints defined by the clauses.

### Input Format
The program expects input in the following format:

```

<lit1> <lit2> ... <litN>

```

Where `lit` is a literal (positive or negative integer), and the list of literals is terminated by an empty line (or EOF).

### How to Run

1. Clone the repository:
```

git clone \<repository\_url>
cd \<repository\_folder>

```

2. Compile the code:
```

gcc -o sat\_solver sat\_solver.c -fopenmp

```

3. Run the program:
```

./sat\_solver

```

4. Input clauses and press Enter. An empty line ends input.

### Example 1: Simple 3-SAT Instance
**Input**:
```

1 -2 3
-1 2 3
-1 -3

```

**Expected Output**:
```

Enter clause(s) and blank line to finish:
Clause 1 (padded and sorted): 1 -2 3
Clause 1 forbidden a\[1..3]: 0 1 0
Clause 2 (padded and sorted): -1 2 3
Clause 2 forbidden a\[1..3]: 1 0 0
Clause 3 (padded and sorted): -1 -3
Clause 3 forbidden a\[1..3]: 1 1 0

Result:
111
110
101

```

### Example 2: Clause with Contradiction (Unsatisfiable)
**Input**:
```

1 -2
2 -1

```

**Expected Output**:
```

Enter clause(s) and blank line to finish:
Unsatisfiable, clause (1) contains both 1 and -1

```

### Example 3: Larger Instance with More Variables
**Input**:
```

1 -2 3 4
-1 2 -3 4
1 2 -3 -4

```

**Expected Output**:
```

Enter clause(s) and blank line to finish:
Clause 1 (padded and sorted): 1 -2 3 4
Clause 1 forbidden a\[1..4]: 0 1 0 0
Clause 2 (padded and sorted): -1 2 -3 4
Clause 2 forbidden a\[1..4]: 1 0 1 0
Clause 3 (padded and sorted): 1 2 -3 -4
Clause 3 forbidden a\[1..4]: 0 0 1 1

Result:
1110
1101
1011

```

### Example 4: Larger Instance with Tail Assignments
**Input**:
```

1 -2
-1 2 3

```

**Expected Output**:
```

Enter clause(s) and blank line to finish:
Clause 1 (padded and sorted): 1 -2
Clause 1 forbidden a\[1..2]: 0 1
Clause 2 (padded and sorted): -1 2 3
Clause 2 forbidden a\[1..3]: 1 0 0

Result:
111
110

```

### Example 5: Maximum Variable Boundaries Test
**Input**:
```

1 2 3
-1 -2 -3
4 5
-4 -5

```

**Expected Output**:
```

Enter clause(s) and blank line to finish:
Clause 1 (padded and sorted): 1 2 3
Clause 1 forbidden a\[1..3]: 0 0 0
Clause 2 (padded and sorted): -1 -2 -3
Clause 2 forbidden a\[1..3]: 1 1 1
Clause 3 (padded and sorted): 4 5
Clause 3 forbidden a\[1..2]: 0 0
Clause 4 (padded and sorted): -4 -5
Clause 4 forbidden a\[1..2]: 1 1

Result:
110
101

```

### Performance Test: Handling Larger Instances

For performance testing, use an input file containing a large number of clauses and variables (e.g., 1000 clauses with 200 variables). You can generate these input files manually or by using a script. 

**Example Input (generated by script)**:
```

1 2 3 ... 1000
-1 -2 -3 ... -1000
...

```

**Expected Output**:
The program should process large instances efficiently without crashing or freezing.

### Troubleshooting

- **Memory Issues**: If the program crashes due to memory allocation failure, try reducing the size of the input or ensure your system has sufficient memory.
- **Concurrency Issues**: The program uses OpenMP for parallel processing. Ensure that your compiler supports OpenMP (`gcc` with `-fopenmp` flag).
- **Segmentation Fault**: If the program segfaults, check the array bounds (especially when accessing the `seen`, `vars`, and `forbidden` arrays). 

### Cleanup and Restart

- If the program detects unsatisfiability or no solution is found, it will clean up allocated memory and restart the loop to allow new input.

### License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

### Contributions

Contributions to improve performance or extend functionality are welcome. Please fork the repository, create a new branch, and submit a pull request.

---

This README provides an extensive set of tests for validating the correctness and performance of the SAT solver program. Ensure to test with various sizes and complexity levels of SAT instances, including unsatisfiable cases, edge cases with variable bounds, and large datasets to validate the program's robustness.
```

This README ensures a comprehensive set of tests, with examples of both satisfiable and unsatisfiable cases, performance scenarios, and error handling. It provides step-by-step guidance for running and testing the program in different environments.
